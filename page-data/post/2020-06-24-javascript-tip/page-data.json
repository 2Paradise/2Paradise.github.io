{"componentChunkName":"component---src-templates-post-template-tsx","path":"/post/2020-06-24-javascript-tip","result":{"data":{"site":{"siteMetadata":{"title":"2Paradise Develop Note","author":"@2Paradise"}},"post":{"html":"<p> javascript 코드 작성에 있어서 알고 있으면 유요한 정보에 대해 알아보자. ES6 문법에 익숙해지도록 학습하며 아래에서 언급한 내용들을 숙지하여 적제적소의 로직에 사용함에 있어 불편함이 없도록 인지해두면 유용한 정보들이다.</p>\n<h2>Truthy and Falsy</h2>\n<p>문법이라기보단 개념에 가까운 이슈이다.</p>\n<pre><code class=\"language-javascript\">function print(person) {\n  if (person === undefined || person === null) {\n    return;\n  }\n  console.log(person.name);\n}\n\nconst person = {\n  name: \"John\"\n};\n\nprint();\n</code></pre>\n<p> 일반적으로 유효한 값 인지 확인 하기 위해 <code>undefined</code> <code>null</code> 을 활용하여 확인하지만 다음과 같이 작성하여도 동일한 코드가 될 수 있다.</p>\n<pre><code class=\"language-javascript\">function print(person) {\n  if (!person) {\n    return;\n  }\n  console.log(person.name);\n}\n\nconst person = {\n  name: \"John\"\n};\n\nprint();\n</code></pre>\n<p><code>undefined</code> <code>null</code> <code>0</code> <code>' '</code> <code>NaN</code> 등은 <strong>Falsy</strong> 한 값 들이 존재한다. 반면 이를 제외한 다른 모든 값들은 <strong>Truthy</strong> 한 값인 것이다. 배열이나 객체 또한 Truthy 한 값에 포함 되므로 위와 같은 코드가 가능한 것이다. 그리고 굳이 <code>!</code> 를 사용하지 않아도 가능하다.</p>\n<h2>단축 평가 논리 계산법</h2>\n<p>(Short - circuit evaluation)</p>\n<p> 논리 연산자를 사용하여 코드를 짧게 작성하는 것을 의미한다.</p>\n<pre><code class=\"language-javascript\">console.log(true &#x26;&#x26; 'hello');\nconsole.log(false &#x26;&#x26; 'hello');\nconsole.log('hello' &#x26;&#x26; 'bye');\n\nconsole.log(null &#x26;&#x26; 'hello');\nconsole.log(undefined &#x26;&#x26; 'hello');\n\nconsole.log(false || 'hello');\nconsole.log(true || 'truthy 하지 않다.');\n\n------------CONSOLE\n\nhello \nfalse\nbye \nnull\nundefined\nhello \ntrue\n</code></pre>\n<p>위와 같이 <code>&#x26;&#x26;</code> 연산의 앞에 값이 Truthy 하면 뒤의 값이 출력된다. 반면 Falsy 한 값이면 앞의 값이 출력된다. 특정값이 유효한지 확인 할 때 주로 확인 한다. </p>\n<p>추가로 <code>||</code> 연산자는 앞의 값이 falsy 할 경우 뒤의 값을 출력하고 그렇지 않으면 앞의 값을 출력한다.</p>\n<pre><code class=\"language-javascript\">const obj = null\n\nconst name = obj &#x26;&#x26; obj.name;\n\n// 위와 같은 경우 obj 가 null 이지만 오류 없이 코드 작성이 가능하다.\n</code></pre>\n<h2>함수의 기본 파라미터</h2>\n<p>함수의 파라미터를 지정하지 않았을 경우를 생각하여 작성하는 코드이다.</p>\n<pre><code class=\"language-javascript\">function calculateCircleArea(r = 1) {\n  return Math.PI * r * r;\n}\n\nconst circleArea = calculateCircleArea();\nconsole.log(circleArea);\n\n--------------------- ES6\n\nconst calculateCircleArea = (r = 1) => Math.PI * r * r;\n\nconst circleArea = calculateCircleArea();\nconsole.log(circleArea);\n</code></pre>\n<p>위와 같이 <code>r=1</code> 과 같은 형식으로 파라미터의 초기값을 지정해 놓을 수 있다. </p>\n<h2>조건문을 스마트하게 활용하는 방법</h2>\n<p><code>||</code> 연산자로 유효값 체크를 할 경우가 많이 있다.</p>\n<pre><code class=\"language-javascript\">const isAnimal = (text) =>{\n  return (text === '고양이' || text === '개' || text === '거북이')\n};\n\nconsole.log(isAnimal('개'));\nconsole.log(isAnimal('노트북'));\n</code></pre>\n<p>반복적인 <code>||</code> 연산자의 작성이 불가피한 유효 값 체크를 <code>includes</code> 함수를 사용하여 간단하게 나타낼 수 있다.</p>\n<pre><code class=\"language-javascript\">const isAnimal = text => {\n  const animals = [\"고양이\", \"개\", \"거북이\"];\n  return animals.includes(text);\n};\n\nconsole.log(isAnimal(\"개\"));\nconsole.log(isAnimal(\"노트북\"));\n\n---------------------ES6\n\nconst isAnimal = text => [\"고양이\", \"개\", \"거북이\"].includes(text);\nconsole.log(isAnimal(\"개\"));\nconsole.log(isAnimal(\"노트북\"));\n</code></pre>\n<p>객체와 단축 평가 논리 계산을 이용하여 아래와 같이 작성도 가능하다.</p>\n<pre><code class=\"language-javascript\">const getSound = animal => {\n  const sounds = {\n    개: \"멍멍\",\n    고양이: \"야옹\",\n    참새: \"짹짹\"\n  };\n  return sounds[animal] || \"...?\";\n};\n\nconsole.log(getSound('개'));\nconsole.log(getSound('낙'));\n</code></pre>\n<h2>비구조화 할당</h2>\n<p>(구조분해)</p>\n<p>비구조화 object value 기본값 설정</p>\n<pre><code class=\"language-javascript\">const obj = { a: 1 };\n\nfunction print({ a, b = 2 }) {\n  console.log(a);\n  console.log(b);\n}\n\nprint(obj);\n\n----------------------------CONSOLE--------------------------\n\n1\n2\n</code></pre>\n<p>비구조화 object key 값 설정 ( 기존 object 는 변하지 않음 )</p>\n<pre><code class=\"language-javascript\">const obj = {\n  name: \"낙\",\n  text: \"hello\"\n};\n\nconst { name: nickname } = obj;\n\nconsole.log(nickname);\nconsole.log(obj);\n\n------CONSOLE--------\n\n낙 \nObject {name: \"낙\", text: \"hello\"}\n</code></pre>\n<p>배열 비구조화 할당</p>\n<pre><code class=\"language-javascript\">const arry = [1];\n\nconst [one, two = 2] = arry;\n\nconsole.log(one);\nconsole.log(two);\n\n--------CONSOLE------\n1\n2\n</code></pre>\n<h2>SPREAD</h2>\n<p>객체 혹은 배열을 펼칠 수 있다.</p>\n<pre><code class=\"language-javascript\">const slime = {\n  name: \"슬라임\"\n};\n\nconst cuteSlime = {\n  name: \"슬라임\",\n  attribute: \"cute\"\n};\n\nconst purpleCuteSlime = {\n  name: \"슬라임\",\n  attribute: \"cute\",\n  color: \"purple\"\n};\n\nconsole.log(slime);\nconsole.log(cuteSlime);\nconsole.log(purpleCuteSlime);\n\n-------------CONSOLE--------------\n\nObject {name: \"슬라임\"}\nObject {name: \"슬라임\", attribute: \"cute\"}\nObject {name: \"슬라임\", attribute: \"cute\", color: \"purple\"}\n</code></pre>\n<p><code>...</code> 을 이용하여 해당 객체의 내용을 가져올 수 있다.</p>\n<pre><code class=\"language-javascript\">const slime = {\n  name: \"슬라임\"\n};\n\nconst cuteSlime = {\n  ...slime,\n  attribute: \"cute\"\n};\n\nconst purpleCuteSlime = {\n  ...cuteSlime,\n  color: \"purple\"\n};\n\nconsole.log(slime);\nconsole.log(cuteSlime);\nconsole.log(purpleCuteSlime);\n\n-------------CONSOLE--------------\n\nObject {name: \"슬라임\"}\nObject {name: \"슬라임\", attribute: \"cute\"}\nObject {name: \"슬라임\", attribute: \"cute\", color: \"purple\"}\n</code></pre>\n<p>배열에서도 사용 가능하다.</p>\n<pre><code class=\"language-javascript\">const animals = [\"개\", \"고양이\", \"참새\"];\nconst another = [...animals, \"낙타\"];\n\nconsole.log(animals);\nconsole.log(another);\n\n-----------CONSOLE-----------\n\n[\"개\", \"고양이\", \"참새\"]\n[\"개\", \"고양이\", \"참새\", \"낙타\"]\n</code></pre>\n<h2>REST</h2>\n<p>쉽게 이해하자면 SPREAD 와 반대로 작동한다고 생각할 수 있다. </p>\n<pre><code class=\"language-javascript\">const purpleCuteSlime = {\n  name: \"슬라임\",\n  attribute: \"cute\",\n  color: \"purple\"\n};\n\nconst { color, ...cuteSlime } = purpleCuteSlime;\nconsole.log(color);\nconsole.log(cuteSlime);\n\nconst { attribute, ...slime } = cuteSlime;\nconsole.log(slime);\n\n---------------CONSOLE------------------\n\npurple \nObject {name: \"슬라임\", attribute: \"cute\"}\nObject {name: \"슬라임\"}\n</code></pre>\n<p>REST 역시 배열에서도 사용가능하다.</p>\n<pre><code class=\"language-javascript\">const nums = [0, 1, 2, 3, 4, 5];\n\nconst [one, two, ...rest] = nums;\n\nconsole.log(one);\nconsole.log(two);\nconsole.log(rest);\n\n------------CONSOLE------------\n\n0\n1\n[2, 3, 4, 5]\n</code></pre>\n<p>함수 파라미터에서의 REST → reduce 와 함께 사용하여 개수가 정해지지 않은 파라미터를 핸들링 할 수 도 있다.</p>\n<pre><code class=\"language-javascript\">function sum(...rest) {\n  return rest.reduce((acc, cur) => acc + cur, 0);\n}\n\nconsole.log(sum(1,2,4,5));\n\n----------------CONSOLE-------------------------\n12\n</code></pre>\n<p>함수 인자에서의 SPREAD → 정의된 배열이 있는 경우 함수의 인자로 SPREAD 할 수 있다.</p>\n<pre><code class=\"language-javascript\">const subtract = (x, y) => x - y;\n\nconst numbers = [1, 2];\nconst result = subtract(...numbers);\nconsole.log(result);\n\n-------------CONSOLE--------------\n-1\n</code></pre>\n<h2>Hoisting</h2>\n<p>아직 선언되지 않은 함수, 변수를 끌어올려 사용하는 작동 방식을 말한다.</p>\n<pre><code class=\"language-javascript\">myFunciton();\n\nfunction myFunciton() {\n  console.log(\"hello\");\n}\n</code></pre>\n<p>위와 같이 코드를 작성 하여도 작동하지만 가급적 이런 형태의 코딩은 유지보수 측면에서 기피해야 한다.</p>","frontmatter":{"type":"post","title":"JavaScript 알고 있으면 유용한 문법","postUrl":"/post/2020-06-24-javascript-tip","tag":["javascript","자바스크립트","ES6"],"date":"2020-06-24","desc":"javascript 코드 작성에 있어서 알고 있으면 유요한 정보에 대해 알아보자. ES6 문법에 익숙해지도록 학습하며 아래에서 언급한 내용들을 숙지하여 적제적소의 로직에 사용함에 있어 불편함이 없도록 인지해두면 유용한 정보들이다."}}},"pageContext":{}},"staticQueryHashes":[]}